// This file contains the resources used by the Incident API for Incident
// Response & Management.
//
// This document follows go/api-style, which should be read before making any
// changes to this file. See also the local style guide in README.md.
//
// == Resources and their relationships:
//
// Incident
//   * Resource representing an incident. Top-level resource.
// Signal
//   * Messages requiring attention from the responder. They can be assigned to
//     at most one incident. Top-level resource.
// Annotation
//   * Notes from responders while investigating and resolving an incident.
//     Sub-resources of an incident.
// Tag
//   * Bit of information about an incident that can be easily parsed both
//     visually as well as programmatically. Sub-resources of an incident.
// IncidentRoleAssignment
//   * Roles filled by individuals, such as Incident Commander. Sub-resources of
//     an incident.
// Artifact
//   * Artifacts such as bugs, cls, and urls related to an incident.
//   Sub-resources of an incident.
// Subscription
//   * Subscription configuration associated with an incident.
//   Sub-resources of an incident.

syntax = "proto3";

package google.cloud.irm.v1alpha2;

option cc_enable_arenas = true;
option java_api_version = 2;
option java_multiple_files = true;
option java_package = "com.google.irm.service.v1alpha2.api";

import "google/api/auditing.proto";
import "google/api/visibility.proto";
import "google/api/policy.proto";
import "google/api/annotations.proto";
import "google/monitoring/v3/metric_service.proto";
import "google/protobuf/timestamp.proto";
import "storage/datapol/annotations/proto/semantic_annotations.proto";

// A user of the IRM app.
message User {
  // One of several ways to uniquely identify a user.
  oneof user {
    // Output only. User id that will allow to get additional information from
    // People API. This field will be populated implicitly if the caller creates
    // or edits a resource (e.g. posts an annotation).
    // (--
    // Only populated for external users. This is the G+ obfuscated gaia id.
    // TODO(b/112079103): Figure out if we can also populate this field for
    // roles (when the caller is the assigned user or not).
    // --)
    string user_id = 1 [(datapol.semantic_type) = ST_GAIA_ID];

    // Email address of the user. This must be associated with a Google account.
    // This field will be set if the user is explicitly identified (verbatim) by
    // email address in an API request (potentially sometime in the past). It
    // will not be populated based on the credentials of a caller of the API.
    // (-- Only populated for external users.
    // TODO(b/111993907): Populate this for incident roles.
    // --)
    string email = 2 [(datapol.semantic_type) = ST_EMAIL_ID];
  }
}

// A signal is a message calling attention to a (potential) incident. An example
// is a page based on a Stackdriver Alerting policy.
// (-- For internal (prod) IRM an example would be a page based on AlertManager
// alerting rules --)
// go/irm-glossary#signal
message Signal {
  // Resource name of the signal, e.g.
  // "projects/{project_id}/signals/{signal_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "signal",
    (google.api.field_auditing).directive = "AUDIT"
  ];
  // Etag to validate the object is unchanged for a read-modify-write operation.
  // An empty etag will overwrite other changes.
  string etag = 2;
  // Resource name of the incident this signal is currently assigned to.
  // May be empty if signal is unassigned.
  string incident = 3;
  // Output only. Time this signal was created.
  google.protobuf.Timestamp create_time = 4;
  // Output only. The user that created this signal for manually created
  // signals. Empty if this signal was generated by a system (e.g. an
  // alerting system).
  // (-- Note: In production, historical data may not have this field set. --)
  User creator = 5;
  // One-line summary of the signal.
  // Immutable.
  string title = 6 [(datapol.semantic_type) = ST_USER_CONTENT];

  // Content type string, e.g. 'text/plain' or'text/html'.
  string content_type = 7;
  // Full message of the signal.
  // Immutable.
  string content = 8;

  // Describes whether the alerting condition is still firing.
  enum State {
    STATE_UNSPECIFIED = 0;  // Unspecified
    STATE_OPEN = 1;         // Firing
    STATE_CLOSED = 2;       // Non-firing
  }
  // Output only. The state of this signal.
  State signal_state = 9;
}

// (--
// TODO(davidcbc): FIgure out a replacement for "SignalDetails"
// --)

// A text annotation by a user.
message Annotation {
  // Resource name of the annotation, e.g.
  // "projects/{project_id}/incidents/{incident_id}/annotations/{annotation_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident_annotation",
    (google.api.field_auditing).directive = "AUDIT"
  ];
  // Output only. Author of the annotation.
  User author = 2;
  // Output only. Time the annotation was created.
  google.protobuf.Timestamp create_time = 3;
  // Content of the annotation. Immutable.
  string content = 4;
}

// A tag by a user.
message Tag {
  // Resource name of a tag, e.g.,
  // "projects/{project_id}/incidents/{incident_id}/tags/{tag_id}"
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident_tag",
    (google.api.field_auditing).directive = "AUDIT"
  ];
  // Display name of the resource (e.g., "cause:rollout"). Immutable.
  string display_name = 2 [(datapol.semantic_type) = ST_USER_CONTENT];
  // Output only. For some tags (e.g., "bug:123"), provide a link to the
  // underlying resource. Optional.
  // (--
  // TODO: Maybe this should be an internal only feature. I don't think we
  // linkify any tags externally (yet), and may use external artifacts instead
  // of using tags for that purpose.
  // --)
  string url = 3 [
    (datapol.semantic_type) = ST_USER_CONTENT,
    (datapol.data_format) = DF_URL
  ];
}

// Synopsis is a summary of an incident and it contains a textual content,
// an author and a last updated timestamp.
message Synopsis {
  // Content type string, e.g. 'text/plain' or 'text/html'.
  string content_type = 1;
  // Textual content of the synopsis. It can be plain text or markdown as
  // indicated by the content_type.
  string content = 2;
  // Last updated timestamp.
  google.protobuf.Timestamp update_time = 3;
  // Author of the synopsis.
  User author = 4;
}

// Source of a metric that is defined in Stackdriver Monitoring API.
message StackdriverMetricSource {
  // A Stackdriver ListTimeSeriesRequest that can be used to retrieve the
  // TimeSeries data.
  google.monitoring.v3.ListTimeSeriesRequest list_timeseries_request = 1;
}

// Defines the threshold for a value.
message Threshold {
  // (-- TODO(davidcbc) Clean up this comment once comparator is included --)
  // Threshold value. The threshold is exceeded if the value of the metric is
  // greater than this value.
  double threshold = 1;

  // (-- TODO(davidcbc): This needs the comparator as well --)
}

// Represents a metric that is displayed for an incident.
message Metric {
  // Title of this metric.
  string title = 1;

  // Source of this metric.
  oneof source {
    // Describes the source of this data from Stackdriver.
    StackdriverMetricSource stackdriver_metric = 2;
  }
  // (-- TODO(davidcbc): Do we need to do something different for metric
  // absence? --)
  // Threshold for the metric.
  Threshold threshold = 3;
}

// Representation of an incident.
message Incident {
  // Output only. Resource name of the incident, e.g.
  // "projects/{project_id}/incidents/{incident_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident",
    (google.api.field_auditing).directive = "AUDIT"
  ];

  // One-line summary of the incident.
  string title = 2 [(datapol.semantic_type) = ST_USER_CONTENT];

  // Specifies the escalation level of this incident, within the IRM protocol
  // for handling incidents.
  enum EscalationLevel {
    // The incident has not been escalated. This is the value used by all new
    // and legacy incidents.
    ESCALATION_LEVEL_UNSPECIFIED = 0;
    // The incident has been escalated to the organizational level.
    ESCALATION_LEVEL_ORGANIZATION = 1;
  }
  // Escalation level of the incident.
  EscalationLevel escalation_level = 3
      [(datapol.semantic_type) = ST_USER_CONTENT];

  // Etag to validate the object is unchanged for a read-modify-write operation.
  // An empty etag will overwrite other changes.
  string etag = 4;

  // Severity of an incident.
  // (-- TODO(b/66443029): Define and document criteria for the different
  // severity levels. --)
  enum Severity {
    // Severity is not specified.
    SEVERITY_UNSPECIFIED = 0;
    // Huge incident.
    SEVERITY_HUGE = 1;
    // Major incident.
    SEVERITY_MAJOR = 2;
    // Medium incident.
    SEVERITY_MEDIUM = 3;
    // Minor incident.
    SEVERITY_MINOR = 4;
    // Negligible incident.
    SEVERITY_NEGLIGIBLE = 5;
  }
  // Severity of the incident.
  Severity severity = 5 [(datapol.semantic_type) = ST_USER_CONTENT];

  // Stage of an incident.
  // (-- TODO(b/68195058): Refine stages description. --)
  enum Stage {
    // This is the default value if no stage has been specified.
    // Note: The caller of the API should set the stage to DETECTED.
    STAGE_UNSPECIFIED = 0;
    // The incident has been detected. This is the initial stage of a new
    // incident.
    // Note: The caller still has to set the stage manually.
    STAGE_DETECTED = 4;
    // This incident has been formally characterized.
    STAGE_TRIAGED = 1;
    // This incident has been mitigated, i.e. does not affect the service level
    // anymore.
    STAGE_MITIGATED = 2;
    // This incident has been fully resolved, i.e. there are no immediate
    // follow-up tasks.
    STAGE_RESOLVED = 3;
    // Postmortem for the incident was written.
    STAGE_DOCUMENTED = 5;
  }
  // Stage of the incident.
  Stage stage = 6 [(datapol.semantic_type) = ST_USER_CONTENT];

  // Output only. Time this incident started. Used to measure the 'elapsed
  // time'. Start time of an incident is the earliest creation time of any of
  // its Signals or the create time of the incident if no Signals are assigned.
  google.protobuf.Timestamp start_time = 7;

  // Output only. Synopsis of this incident.
  // (--
  // TODO: update_time and author are actually output only fields and generated
  // by the backend. Clearing synopsis.content removes the whole
  // synopsis. Maybe there is a better way to model this. Otherwise these
  // details need to be documented more clearly.
  // --)
  Synopsis synopsis = 8;
}

// Describes a role that can be assigned to an incident.
message IncidentRole {
  // List of possible roles.
  // (--
  // TODO(acrume): Define how this works and who is responsible for what.
  // --)
  enum Type {
    // The role is unspecified.
    TYPE_UNSPECIFIED = 0;
    // Incident Commander: Manages response plan, near-term and long-term
    // objectives, establishes priorities, and delegates tasks as needed.
    TYPE_INCIDENT_COMMANDER = 1;
    // Communications Lead: Keeps everybody outside and within the response team
    // informed.
    TYPE_COMMUNICATIONS_LEAD = 2;
    // Operations Lead: Figures out what to do, and gets it done.
    TYPE_OPERATIONS_LEAD = 3;
    // External Customer Communications Lead: Responsible for communicating
    // incident details to customers/public.
    TYPE_EXTERNAL_CUSTOMER_COMMUNICATIONS_LEAD = 4;
    // Primary Oncall: Responds to the initial page and handles all
    // responsibilities for pre-escalated incidents.
    TYPE_PRIMARY_ONCALL = 5;
    // Secondary Oncall: Helps the primary oncall if necessary; mostly useful
    // for pre-escalated incidents.
    TYPE_SECONDARY_ONCALL = 6;
    // User-specified roles. One example is a Planning Lead, who keeps track of
    // the incident. Another is an assistant Incident Commander.
    TYPE_OTHER = 7;
  }
  // The type of role. The role type is immutable in role assignments. Each role
  // type can only be used once per incident, except for TYPE_OTHER.
  Type type = 1 [(datapol.semantic_type) = ST_USER_CONTENT];

  // (-- api-linter: output-only-format=disabled --)
  // Output only unless TYPE_OTHER is used. Title of the role. For TYPE_OTHER,
  // must be unique within an incident.
  string title = 2 [(datapol.semantic_type) = ST_USER_CONTENT];

  // (-- api-linter: output-only-format=disabled --)
  // Output only unless TYPE_OTHER is used. Description of the role.
  string description = 3 [(datapol.semantic_type) = ST_USER_CONTENT];
}

// Stores the assignee of a role as well as the proposed next assignee.
message IncidentRoleAssignment {
  // Output only. Resource name such as
  // "projects/{project_id}/incidents/{incident_id}/role_assignments/{role_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident_role",
    (google.api.field_auditing).directive = "AUDIT"
  ];

  // Output only. Etag for this version of the resource. Must be specified in
  // update requests and match the current version in storage. Must not be
  // modified by the client.
  string etag = 2;

  // The role that is or will be assigned.
  IncidentRole role = 3;

  // The user this role is assigned to. This field can only be directly set
  // during creation request. Subsequent updates are done via the
  // IncidentRoleHandover methods.
  User assignee = 4;

  // The recipient of a requested role handoff. This field can only be directly
  // set during creation request. Subsequent updates are done via the
  // IncidentRoleHandover methods.
  //
  // `assignee` is always the current role-holder, and `proposed_assignee` is
  // used to track unfinished assignments and handoffs. Let's say Bob assigns
  // Alice to a role. Then the fields are:
  //   `assignee`: nil, `proposed_assignee`: Alice
  // If Alice accepts, then the fields are:
  //   `assignee`: Alice, `proposed_assignee`: nil
  // If she cancels, then the RoleAssignment is deleted.
  // Let's say Alice has the role. Then the fields are:
  //   `assignee`: Alice, `proposed_assignee`: nil
  // If Alice becomes incapacitated and Bob requests Carol to take over, then
  // the fields are:
  //   `assignee`: Alice, `proposed_assignee`: Carol
  // After Carol accepts the handover, the fields are:
  //   `assignee`: Carol, `proposed_assignee`: nil
  // Or if Carol refuses the handover, the fields are:
  //   `assignee`: Alice, `proposed_assignee`: nil
  User proposed_assignee = 5;
}

// External artifact associated to an incident.
message Artifact {
  // Output only. Resource name such as
  // "projects/{project_id}/incidents/{incident_id}/artifacts/{artifact_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident_artifact",
    (google.api.field_auditing).directive = "AUDIT"
  ];

  // User provided name of an artifact.
  string display_name = 2 [(datapol.semantic_type) = ST_USER_CONTENT];

  // Output only. Etag for this version of the resource. Must be specified in
  // update requests and match the current version in storage. Must not be
  // modified by the client.
  string etag = 3;


  // URL to access the artifact.
  string url = 4 [
    (datapol.semantic_type) = ST_USER_CONTENT,
    (datapol.data_format) = DF_URL
  ];

  // Possible types of an artifact.
  enum Type {
    // External type is unspecified.
    TYPE_UNSPECIFIED = 0;
    // URL.
    TYPE_URL = 1;
    // (-- TODO(davidcbc): Do these make sense to be exposed externally? --)
    // An issue. (--e.g. Buganizer bug--)
    TYPE_ISSUE = 2;
    // A source control change. (-- e.g. a Piper changelist --)
    TYPE_SOURCE_CONTROL_CHANGE = 3;
    // A JIRA issue.
    TYPE_JIRA_ISSUE = 4;
  }

  // Type of this artifact.
  Type type = 5 [(datapol.semantic_type) = ST_USER_CONTENT];
}

// Communication Channels are mechanisms used to receive notifications
// about changes to incidents.
message CommunicationChannel {
  // A communication channel that delivers messages to an email address.
  message Email {
    // The email address, e.g. "user@example.com".
    string address = 1 [(datapol.semantic_type) = ST_EMAIL_ID];
  }
  // A communication channel that delivers messages to a Stackdriver
  // notification channel.
  message NotificationChannel {
    // Stackdriver notification channel name.
    string name = 1;
  }
  // An endpoint describes how messages will be delivered.
  oneof endpoint {
    // Messages will be delivered via email.
    Email email = 1;
    // Messages will be delivered via a Stackdriver notification channel.
    // (-- This is only valid in Cloud. --)
    NotificationChannel notification_channel = 2;
  }
}

// A subscription allows users to get notifications about changes to
// an incident.
message Subscription {
  // Output only. Resource name such as
  // "projects/{project_id}/incidents/{incident_id}/subscriptions/{subscription_id}".
  string name = 1 [
    (datapol.semantic_type) = ST_IDENTIFYING_ID,
    (google.api.field_policy).resource_type = "incident_subscription",
    (google.api.field_auditing).directive = "AUDIT"
  ];

  // Output only. Etag for this version of the resource. Must be specified in
  // update requests and match the current version in storage. Must not be
  // modified by the client.
  string etag = 2;

  // A communications channel to send subscription messages to.
  CommunicationChannel subscription_channel = 3;

  // Types of changes that users can subscribe to in an incident.
  enum EventType {
    // An event_type that's not specified is an error.
    EVENT_TYPE_UNSPECIFIED = 0;
    // The incident's title has changed.
    EVENT_TYPE_TITLE_CHANGE = 1;
    // The incident's synopsis has changed.
    EVENT_TYPE_SYNOPSIS_CHANGE = 2;
    // The incident's stage has changed.
    EVENT_TYPE_STAGE_CHANGE = 3;
    // The incident's severity has changed.
    EVENT_TYPE_SEVERITY_CHANGE = 4;
    // A new annotation has been added to the incident.
    EVENT_TYPE_ANNOTATION_ADD = 5;
    // An annotation has been modified.
    EVENT_TYPE_ANNOTATION_CHANGE = 6;
  }

  // Types of events this subscription receives notifications for.
  repeated EventType event_types = 4
      [(datapol.semantic_type) = ST_USER_CONTENT];
}
